# user.js
#
# A local user; distinct from a person
#
# Copyright 2011,2012 StatusNet Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
databank = require("databank")
_ = require("underscore")
DatabankObject = databank.DatabankObject
Stamper = require("../stamper").Stamper
bcrypt = require("bcrypt")
Step = require("step")
Person = require("./person").Person
Stream = require("./stream").Stream
Collection = require("./collection").Collection
Activity = require("./activity").Activity
ActivityObject = require("./activityobject").ActivityObject
Edge = require("./edge").Edge
Favorite = require("./favorite").Favorite
URLMaker = require("../urlmaker").URLMaker
IDMaker = require("../idmaker").IDMaker
NoSuchThingError = databank.NoSuchThingError
User = DatabankObject.subClass("user")
exports.User = User

# for updating
User::beforeUpdate = (props, callback) ->
  
  # XXX: required, but immutable. Boooooo.
  unless _(props).has("nickname")
    callback new Error("'nickname' property is required"), null
    return
  else if props.nickname isnt @nickname
    callback new Error("'nickname' is immutable"), null
    return
  else
    delete props.nickname
  
  # XXX: required. Seems not strictly necessary, but whatever.
  unless _(props).has("password")
    callback new Error("'password' property is required"), null
    return
  
  # Callers must omit or leave equal
  if _(props).has("published")
    if props.published isnt @published
      callback new Error("'published' is autogenerated and immutable"), null
      return
    else
      delete props.published
  
  # Callers must omit or leave equal
  if _(props).has("profile")
    
    # XXX: we should probably do some deep-equality check
    if not _(props.profile).has("id") or props.profile.id isnt @profile.id or not _(props.profile).has("objectType") or props.profile.objectType isnt @profile.objectType or not _(props.profile).has("displayName") or props.profile.displayName isnt @profile.displayName
      callback new Error("'profile' is immutable"), null
      return
    else
      delete props.profile
  
  # Callers must omit or leave equal
  if _(props).has("updated") and props.updated isnt @updated
    callback new Error("'updated' is autogenerated"), null
    return
  props.updated = Stamper.stamp()
  Step (->
    bcrypt.genSalt 10, this
  ), ((err, salt) ->
    throw err  if err
    bcrypt.hash props.password, salt, this
  ), (err, hash) ->
    if err
      callback err, null
    else
      props.passwordHash = hash
      delete props.password

      callback null, props



# For creating
User.beforeCreate = (props, callback) ->
  if not props.nickname or not props.password
    callback new Error("Gotta have a nickname and a password."), null
    return
  now = Stamper.stamp()
  props.published = props.updated = now
  Step (->
    bcrypt.genSalt 10, this
  ), ((err, salt) ->
    throw err  if err
    bcrypt.hash props.password, salt, this
  ), ((err, hash) ->
    pprops = undefined
    throw err  if err
    props.passwordHash = hash
    delete props.password

    pprops =
      preferredUsername: props.nickname
      url: URLMaker.makeURL(props.nickname)
      displayName: props.nickname

    if URLMaker.port is 80
      pprops.id = "acct:" + props.nickname + "@" + URLMaker.hostname
      pprops.uuid = IDMaker.makeID()
      pprops.links = self:
        href: URLMaker.makeURL("api/person/" + pprops.uuid)
    Person.create pprops, this
  ), (err, person) ->
    throw err  if err
    props.profile = new Person(
      objectType: "person"
      id: person.id
    )
    callback null, props


User::afterCreate = (callback) ->
  user = this
  Step (->
    i = undefined
    streams = ["inbox", "outbox", "inbox:major", "outbox:major", "inbox:minor", "outbox:minor", "followers", "following", "favorites", "lists"]
    group = @group()
    i = 0
    while i < streams.length
      Stream.create
        name: "user:" + user.nickname + ":" + streams[i]
      , group()
      i++
  ), ((err, streams) ->
    i = undefined
    lists = ["Friends", "Family", "Acquaintances", "Coworkers", "Following"]
    group = @group()
    throw err  if err
    i = 0
    while i < lists.length
      Collection.create
        author: user.profile
        displayName: lists[i]
        objectTypes: ["person"]
      , group()
      i++
  ), (err, groups) ->
    if err
      callback err
    else
      callback null


User::sanitize = ->
  delete @password

  delete @passwordHash

User::getProfile = (callback) ->
  user = this
  Step (->
    ActivityObject.getObject user.profile.objectType, user.profile.id, this
  ), (err, profile) ->
    if err
      callback err, null
    else
      callback null, profile


User::getFollowers = (start, end, callback) ->
  @getPeople "user:" + @nickname + ":followers", start, end, callback

User::getFollowing = (start, end, callback) ->
  @getPeople "user:" + @nickname + ":following", start, end, callback

User::getPeople = (stream, start, end, callback) ->
  ActivityObject.getObjectStream "person", stream, start, end, callback

User::followerCount = (callback) ->
  Stream.count "user:" + @nickname + ":followers", callback

User::followingCount = (callback) ->
  Stream.count "user:" + @nickname + ":following", callback

User::follow = (id, callback) ->
  user = this
  Step (->
    Edge.create
      from:
        id: user.profile.id
        objectType: user.profile.objectType

      to:
        id: id
        objectType: "person"
    , this
  ), ((err, edge) ->
    throw err  if err
    Stream.get "user:" + user.nickname + ":following", this
  ), ((err, stream) ->
    throw err  if err
    stream.deliver id, this
  ), ((err) ->
    throw err  if err
    User.fromPerson id, this
  ), ((err, other) ->
    throw err  if err
    unless other
      
      # XXX: Remote follow
      callback null
    else
      Stream.get "user:" + other.nickname + ":followers", this
  ), ((err, stream) ->
    throw err  if err
    stream.deliver user.profile.id, this
  ), (err) ->
    if err
      callback err
    else
      callback null


User::stopFollowing = (id, callback) ->
  user = this
  Step (->
    Edge.get Edge.id(user.profile.id, id), this
  ), ((err, edge) ->
    throw err  if err
    edge.del this
  ), ((err) ->
    throw err  if err
    Stream.get "user:" + user.nickname + ":following", this
  ), ((err, stream) ->
    throw err  if err
    stream.remove id, this
  ), ((err) ->
    throw err  if err
    User.fromPerson id, this
  ), ((err, other) ->
    throw err  if err
    unless other
      
      # XXX: Remote follow
      callback null
    else
      Stream.get "user:" + other.nickname + ":followers", this
  ), ((err, stream) ->
    throw err  if err
    stream.remove user.profile.id, this
  ), (err) ->
    if err
      callback err
    else
      callback null


User::favorite = (id, objectType, callback) ->
  user = this
  Step (->
    Favorite.create
      from:
        id: user.profile.id
        objectType: user.profile.objectType

      to:
        id: id
        objectType: objectType
    , this
  ), ((err, edge) ->
    throw err  if err
    Stream.get "user:" + user.nickname + ":favorites", this
  ), ((err, stream) ->
    throw err  if err
    
    # XXX: hackery!
    stream.deliver id + "|" + objectType, this
  ), ((err) ->
    throw err  if err
    ActivityObject.ensureObject
      id: id
      objectType: objectType
    , this
  ), ((err, other) ->
    throw err  if err
    other.favoritedBy user.profile.id, this
  ), (err) ->
    if err
      callback err
    else
      callback null


User::unfavorite = (id, objectType, callback) ->
  user = this
  Step (->
    Favorite.get Favorite.id(user.profile.id, id), this
  ), ((err, favorite) ->
    throw err  if err
    favorite.del this
  ), ((err) ->
    throw err  if err
    Stream.get "user:" + user.nickname + ":favorites", this
  ), ((err, stream) ->
    throw err  if err
    
    # XXX: hackery!
    stream.remove id + "|" + objectType, this
  ), ((err) ->
    throw err  if err
    ActivityObject.ensureObject
      id: id
      objectType: objectType
    , this
  ), ((err, other) ->
    throw err  if err
    other.unfavoritedBy user.profile.id, this
  ), (err) ->
    if err
      callback err
    else
      callback null


User::getFavorites = (start, end, callback) ->
  user = this
  ids = undefined
  Step (->
    Stream.get "user:" + user.nickname + ":favorites", this
  ), ((err, stream) ->
    throw err  if err
    stream.getIDs start, end, this
  ), ((err, results) ->
    i = undefined
    parts = undefined
    group = @group()
    throw err  if err
    ids = results
    if ids.length is 0
      callback null, []
    else
      i = 0
      while i < ids.length
        
        # XXX: hackery. we pack id|objectType into the id slot. Shh!
        parts = ids[i].split("|")
        ActivityObject.getObject parts[1], parts[0], group()
        i++
  ), (err, objects) ->
    if err
      callback err, null
    else
      
      # XXX: I *think* these should be in the same order
      # as ids array.
      callback null, objects


User::favoritesCount = (callback) ->
  Stream.count "user:" + @nickname + ":favorites", (err, count) ->
    if err and err instanceof NoSuchThingError
      callback null, 0
    else if err
      callback err, null
    else
      callback null, count


User::expand = (callback) ->
  user = this
  ActivityObject.expandProperty user, "profile", callback

User.fromPerson = (id, callback) ->
  Step (->
    User.search
      "profile.id": id
    , this
  ), (err, results) ->
    if err
      callback err, null
    else if results.length is 0
      callback null, null
    else
      callback null, results[0]


User::addToOutbox = (activity, callback) ->
  user = this
  adder = (getter) ->
    (user, activity, callback) ->
      Step (->
        getter user, this
      ), (err, stream) ->
        throw err  if err
        stream.deliver activity.id, callback


  addToMain = adder((user, cb) ->
    user.getOutboxStream cb
  )
  addToMajor = adder((user, cb) ->
    user.getMajorOutboxStream cb
  )
  addToMinor = adder((user, cb) ->
    user.getMinorOutboxStream cb
  )
  Step (->
    addToMain user, activity, @parallel()
    if activity.isMajor()
      addToMajor user, activity, @parallel()
    else
      addToMinor user, activity, @parallel()
  ), callback

User::addToInbox = (activity, callback) ->
  user = this
  adder = (getter) ->
    (user, activity, callback) ->
      Step (->
        getter user, this
      ), ((err, stream) ->
        throw err  if err
        stream.deliver activity.id, this
      ), callback

  addToMain = adder((user, cb) ->
    user.getInboxStream cb
  )
  addToMajor = adder((user, cb) ->
    user.getMajorInboxStream cb
  )
  addToMinor = adder((user, cb) ->
    user.getMinorInboxStream cb
  )
  Step (->
    addToMain user, activity, @parallel()
    if activity.isMajor()
      addToMajor user, activity, @parallel()
    else
      addToMinor user, activity, @parallel()
  ), callback


# Check the credentials for a user
# callback takes args:
# - err: if there's an error (NB: null if credentials don't match)
# - user: User object or null if credentials don't match
User.checkCredentials = (nickname, password, callback) ->
  user = null
  Step (->
    User.get nickname, this
  ), ((err, result) ->
    if err
      if err instanceof NoSuchThingError
        callback null, null
        return # done
      else
        throw err
    else
      user = result
      bcrypt.compare password, user.passwordHash, this
  ), (err, res) ->
    if err
      callback err, null
    else unless res
      callback null, null
    else
      
      # Don't percolate that hash around
      user.sanitize()
      callback null, user


User::getInboxStream = (callback) ->
  Stream.get "user:" + @nickname + ":inbox", callback

User::getOutboxStream = (callback) ->
  Stream.get "user:" + @nickname + ":outbox", callback

User::getMajorInboxStream = (callback) ->
  Stream.get "user:" + @nickname + ":inbox:major", callback

User::getMajorOutboxStream = (callback) ->
  Stream.get "user:" + @nickname + ":outbox:major", callback

User::getMinorInboxStream = (callback) ->
  Stream.get "user:" + @nickname + ":inbox:minor", callback

User::getMinorOutboxStream = (callback) ->
  Stream.get "user:" + @nickname + ":outbox:minor", callback

User::getLists = (callback) ->
  Stream.get "user:" + @nickname + ":lists", callback

User.schema =
  pkey: "nickname"
  fields: ["passwordHash", "published", "updated", "profile"]
  indices: ["profile.id"]
